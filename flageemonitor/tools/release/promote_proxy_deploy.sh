#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../../.." && pwd)"
DEPLOY_REMOTE_DEFAULT="flageemonitor-proxy"
DEPLOY_BRANCH_DEFAULT="main"
PUSH_CHANGES=0
DRY_RUN=0
DEPLOY_REMOTE="${DEPLOY_REMOTE_DEFAULT}"
DEPLOY_BRANCH="${DEPLOY_BRANCH_DEFAULT}"

usage() {
  cat <<USAGE
Uso:
  $0 [--deploy-remote NAME] [--deploy-branch BRANCH] [--push] [--dry-run]

Descricao:
  Promove artefatos permitidos do workspace atual para o repositório de deploy do proxy,
  com validações de segurança e bloqueio de conteúdo interno.

Opcoes:
  --deploy-remote NAME   Remote git de destino (default: ${DEPLOY_REMOTE_DEFAULT})
  --deploy-branch NAME   Branch de destino (default: ${DEPLOY_BRANCH_DEFAULT})
  --push                 Faz push ao final (default: desabilitado)
  --dry-run              Gera staging e validações, sem commit
USAGE
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --deploy-remote)
      DEPLOY_REMOTE="$2"
      shift 2
      ;;
    --deploy-branch)
      DEPLOY_BRANCH="$2"
      shift 2
      ;;
    --push)
      PUSH_CHANGES=1
      shift
      ;;
    --dry-run)
      DRY_RUN=1
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "Argumento invalido: $1"
      usage
      exit 1
      ;;
  esac
done

require_cmd() {
  command -v "$1" >/dev/null 2>&1 || { echo "Comando obrigatorio ausente: $1"; exit 1; }
}

require_cmd git
require_cmd rsync
require_cmd rg

if ! git -C "$ROOT_DIR" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  echo "Diretorio raiz nao e um repositorio git valido: $ROOT_DIR"
  exit 1
fi

DEPLOY_URL="$(git -C "$ROOT_DIR" remote get-url "$DEPLOY_REMOTE" 2>/dev/null || true)"
if [[ -z "$DEPLOY_URL" ]]; then
  echo "Remote '$DEPLOY_REMOTE' nao encontrado no repo local."
  echo "Remotes atuais:"
  git -C "$ROOT_DIR" remote -v || true
  exit 1
fi

verify_pyarmor_runtime() {
  local runtime_dir="$ROOT_DIR/proxy/runtime"
  if [[ ! -d "$runtime_dir" ]]; then
    echo "Runtime nao encontrado em $runtime_dir"
    echo "Execute: bash /ariusmonitor/build/build_protegido.sh"
    exit 1
  fi

  if [[ ! -f "$runtime_dir/pyarmor_runtime_000000/pyarmor_runtime.so" ]]; then
    echo "Runtime PyArmor ausente em $runtime_dir/pyarmor_runtime_000000/pyarmor_runtime.so"
    exit 1
  fi

  local unprotected
  unprotected="$(find "$runtime_dir" -type f -name '*.py' ! -path '*/__pycache__/*' -exec grep -L '__pyarmor__' {} + || true)"
  if [[ -n "$unprotected" ]]; then
    echo "Arquivos sem marcador PyArmor encontrados no runtime:"
    echo "$unprotected"
    exit 1
  fi
}

verify_pyarmor_runtime

TMP_DIR="$(mktemp -d)"
trap 'rm -rf "$TMP_DIR"' EXIT
DEPLOY_WORKTREE="$TMP_DIR/deploy-repo"

echo "Clonando destino: $DEPLOY_URL ($DEPLOY_BRANCH)"
if git ls-remote --heads "$DEPLOY_URL" "$DEPLOY_BRANCH" | grep -q .; then
  git clone --depth 1 --branch "$DEPLOY_BRANCH" "$DEPLOY_URL" "$DEPLOY_WORKTREE"
elif git ls-remote --heads "$DEPLOY_URL" | grep -q .; then
  echo "Branch '$DEPLOY_BRANCH' nao encontrada. Clonando branch padrao e criando '$DEPLOY_BRANCH'."
  git clone --depth 1 "$DEPLOY_URL" "$DEPLOY_WORKTREE"
  git -C "$DEPLOY_WORKTREE" checkout -B "$DEPLOY_BRANCH"
else
  echo "Repositorio de deploy sem branches. Inicializando worktree local em '$DEPLOY_BRANCH'."
  git init "$DEPLOY_WORKTREE" >/dev/null
  git -C "$DEPLOY_WORKTREE" remote add origin "$DEPLOY_URL"
  git -C "$DEPLOY_WORKTREE" checkout -b "$DEPLOY_BRANCH" >/dev/null
fi

# Limpa worktree, preservando apenas .git
find "$DEPLOY_WORKTREE" -mindepth 1 -maxdepth 1 ! -name .git -exec rm -rf {} +

copy_path() {
  local rel="$1"
  local src="$ROOT_DIR/$rel"
  local dst="$DEPLOY_WORKTREE/$rel"

  if [[ ! -e "$src" ]]; then
    echo "Aviso: caminho ausente e ignorado: $rel"
    return 0
  fi

  mkdir -p "$(dirname "$dst")"
  if [[ -d "$src" ]]; then
    rsync -a --delete "$src/" "$dst/"
  else
    cp -f "$src" "$dst"
  fi
}

# Allowlist de conteúdo permitido no repositório de deploy
ALLOWED_PATHS=(
  "proxy/runtime"
  "proxy/scripts"
  "proxy/host-linux"
  "proxy/postgresql"
  "proxy/utilities"
  "proxy/docker"
  "proxy/requirements.txt"
  "assets/certi_api.pem"
  "flageemonitor/proxy/docker"
  "flageemonitor/proxy/scripts/docker"
  "flageemonitor/proxy/bootstrap"
  "flageemonitor/proxy/README.md"
  "flageemonitor/proxy/docker/README.md"
)

for p in "${ALLOWED_PATHS[@]}"; do
  copy_path "$p"
done

cat > "$DEPLOY_WORKTREE/DEPLOY_MANIFEST.txt" <<MANIFEST
Generated by: flageemonitor/tools/release/promote_proxy_deploy.sh
Source repo: $(git -C "$ROOT_DIR" remote get-url origin 2>/dev/null || echo unknown)
Source commit: $(git -C "$ROOT_DIR" rev-parse HEAD)
Source short:  $(git -C "$ROOT_DIR" rev-parse --short HEAD)
Generated at:  $(date -u +"%Y-%m-%dT%H:%M:%SZ")

Allowed paths:
$(printf '%s\n' "${ALLOWED_PATHS[@]}")
MANIFEST

# Guardrails de conteúdo proibido no deploy
FORBIDDEN_PATH_PATTERNS=(
  "proxy/sources"
  "proxy/.venv"
  "server"
  "flageemonitor/server"
)

for pat in "${FORBIDDEN_PATH_PATTERNS[@]}"; do
  if find "$DEPLOY_WORKTREE" -path "$DEPLOY_WORKTREE/$pat" -print -quit | grep -q .; then
    echo "Conteudo proibido detectado no deploy: $pat"
    exit 1
  fi
done

if rg -n "ghp_[A-Za-z0-9]{20,}|AKIA[0-9A-Z]{16}|-----BEGIN (RSA|OPENSSH|EC) PRIVATE KEY-----" "$DEPLOY_WORKTREE" >/dev/null 2>&1; then
  echo "Possivel segredo detectado no staging de deploy. Abortando."
  rg -n "ghp_[A-Za-z0-9]{20,}|AKIA[0-9A-Z]{16}|-----BEGIN (RSA|OPENSSH|EC) PRIVATE KEY-----" "$DEPLOY_WORKTREE" || true
  exit 1
fi

pushd "$DEPLOY_WORKTREE" >/dev/null

if [[ -z "$(git config user.email || true)" ]]; then
  git config user.email "$(git -C "$ROOT_DIR" config user.email || echo 'release-bot@flagee.local')"
fi
if [[ -z "$(git config user.name || true)" ]]; then
  git config user.name "$(git -C "$ROOT_DIR" config user.name || echo 'Flagee Release Bot')"
fi

git add -A
if git diff --cached --quiet; then
  echo "Nenhuma mudanca para promover."
  exit 0
fi

if [[ "$DRY_RUN" -eq 1 ]]; then
  echo "Dry-run habilitado: mudancas preparadas, sem commit."
  git status --short
  exit 0
fi

COMMIT_MSG="release(proxy): promote from $(git -C "$ROOT_DIR" rev-parse --short HEAD)"
git commit -m "$COMMIT_MSG"

echo "Commit criado no staging de deploy:"
git --no-pager log --oneline -1

if [[ "$PUSH_CHANGES" -eq 1 ]]; then
  git push origin "$DEPLOY_BRANCH"
  echo "Push realizado para origin/$DEPLOY_BRANCH"
else
  echo "Push nao realizado (modo seguro). Use --push para publicar."
fi

popd >/dev/null
